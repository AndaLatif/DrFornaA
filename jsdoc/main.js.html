<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: main.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: main.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as d3new from "d3"
import * as domtoimage from "dom-to-image"
import {FornaContainer, RNAUtilities, rnaTreemap, rnaPlot} from 'fornac';
//@ts-check
var rnaUtilities = new RNAUtilities();
let containers = {};
/**
 * Occupancy Treshhold
 * @type {float}
 */
const occupancyTreshold = 0.01

/**
 * Prepares the plotting area:
 ** removes the previous content
 ** displays loading indicator
 ** creates the visual container containing the treemap
 ** create the table container containing the structures for the selected time point
 * @param {string} elementName the name of the HTML element
 * @param {string} notificationContent the notification to appear
 
 */
function preparePlotArea(elementName, notificationContent = 'Loading...') {  

    /**
     * remove the previous content
     *  
    */
    let container = d3new.select(elementName)
    container.selectAll('div')
        .remove()
    
    
    /**
     * display loading indicator
     *  
    */
    container.style('text-align', 'center')
        .append('div')
        .attr('id', 'loadingNotification')
        .style('display', 'inline')
        .html(notificationContent)

    /**
     * create the visual container containing the treemap
     *  
    */
    container
        .append('div')
        .attr('id', 'visContainer')
        .attr("height", 500)
        
    /**
     * create the table container containing the structures for the selected time point
     *  
    */
    container
        .append('div')
        .attr('id', 'tableContainer')
        .html(" &lt;p>and time table container-most populated structure&lt;/p>")
}
/**
 * Current file name
 * @type {string}
 */
let filename=""
start();
/**
 * Starts the visualization: 
 *
 */
function start() {
    readFromFileRadio();
    readFromFileUpload();
    d3new.select("#downloadButton").on('click', function() {
        //console.log("here")
        downloadPng(document.getElementById('drTrafoContainer'));
})
} 
 /**
     * 
    * method for reading the input from a selected file
    * 
    */  
function readFromFileRadio(){
   
    //read selected example 
    document.querySelectorAll('.forminput').forEach((item) => {
        item.addEventListener('change', (event) => {
            document.querySelectorAll('.fileinput').forEach((item)=>{item.lastElementChild.value=""})
             filename = item.lastElementChild.value
             
       // filename=fileName
            let a = []
            d3new.text(filename).then(d => {
                a = d3new.csvParse(d.replace(/ +/g, ","))
                containers = {};
                let container = d3new.select("#visContainer")
                container.remove()
                
                ShowData(Array.from(a))
            })
        })
    })

    
}
 /**
     * 
    * method for reading the input from an uploaded file
    *  
    */  
function readFromFileUpload(){
   
    document.querySelectorAll('.fileinput').forEach((item) => {
    item.addEventListener('change', (event) => {
        let rb=document.querySelectorAll('input[type=radio][name=fileinput]:checked')
        //console.log(rb)
        if (rb.length!=0)
            {rb[0].checked=false}
    
   
       let files = event.target.files
        filename=files[0].name
        console.log(filename)
       //console.log(files)
       
        for (let i = 0, f; f = files[i]; i++) {
            let reader = new FileReader()
            reader.onload = (val) => {                                   
               let a=[]
              
               a = d3new.csvParse(val.target.result.replace(/ +/g, ",").replace(/\n,+/g, "\n"))  
               console.log(a)
               //a = d3new.csvParse(a.replace("\n,", "\n"))    
                containers = {}; 

               ShowData(a)
            }            
            reader.readAsText(f);
        }
    });
 })
}

/**
 * Function for downloading the content of the container,
 ** the name of the downloaded file is generated using the name of the current selected file, the current time and the current date. 
 ** also dispays a notification when the file was downloaded
 * @param {string} elem name of the container
 
 */
function downloadPng(elem) {
    //console.log('Downloading... ', elem)
    domtoimage.toPng(elem)
    .then(function (dataUrl) {
        let link = document.createElement('a');
        let today=new Date()
        let date = today.getFullYear()+'_'+(today.getMonth()+1)+'_'+today.getDate();
        let time = today.getHours() + "_" + today.getMinutes() + "_" + today.getSeconds();
       
        link.download = filename+"_"+date+"_"+time+'.png';
        alert("File "+link.download+" was downloaded")
        link.href = dataUrl;
        link.click();
    });
}

let logscale;
let scalel;
let svg;
let realtime;
let prevtime=null
let strtoPlotprev=null;
/**
 * Current file name
 * @type {integer}
 */
let sequenceLength = null;
/**
 * Current file name
 * @type {boolean}
 */
let mouseactive=false;

/**
 * Method for dispaying the input data
 * @param {Array} data The input data read form the file
 */
function ShowData(data) {
    containers = {};
    preparePlotArea(drTrafoContainer); 
    let container = d3new.select("#drTrafoContainer");
    container.select('#loadingNotification').remove(); //remove the loading notification 
    
    prevtime=null
    strtoPlotprev=null
    sequenceLength=data[data.length - 1].structure.length; //length of the transcribed sequence, used for seeing when the transcription ends
    
    let visContainerWidth = d3new.select('#visContainer').node().getBoundingClientRect().width; //for resizing with window resize
    let lineChartWidth = visContainerWidth * .98; 
    let tableContainer = d3new.select(`#tableContainer`);
    tableContainer.selectAll("svg").remove()
    mouseactive=false
    const onResize = () => {
        //retain position we are at and if animation was on an remake plots accordingly!?? TODO?
        //maybe not delete everything but just resize
        playAnimation = false        
        tableContainer.selectAll("#timesvg").remove() //remove time scale
        //viscontainer.selectAll(".div").selectAll(".svg").remove() 
        viscontainer.selectAll("#treemapdiv").remove()//remove plots
        ShowData(data);// redraw plots
    }

    window.addEventListener("resize", debounce(onResize, 1000)); //when the window was resize, call the onResize function after 1000 ms

    let viscontainer = d3new.select('#visContainer')
    viscontainer.append('div').attr('id','treemapdiv').style('height', '500px')
    
    

    let filteredData = data.filter((d) => { return d.occupancy > occupancyTreshold })//select structures with high enough occupancy
   // let nestedID=Array.from(d3new.group(filteredData, d => d.id)) //extract all the id's that occur, I actually only need id and structure in dot bracket 
                    // assign equal ocupancies to all the structures and create treemaps with the plots 
                    //such that later I only resize the plots, not regenerate them for every time step
                    //to have less lag
    //console.log(nestedID)
    let nestedData = Array.from(d3new.group(filteredData, d => d.time))//nest data by  time points to extract the structures to plot for every time step
    
    // having the sequence length at the end, the end of transciption is identified as the first time step where the structures of that length occur
    let trascriptionSteps=[] 
    let AfterTrascription=[]
    let maxNoStr=0
    nestedData.forEach(el=>{
        if (el[1].length>maxNoStr){
        maxNoStr=el[1].length //detect how many alternatives apear maximally 
        }
        if (el[1][0].structure.length&lt;sequenceLength){ //if the structure is not at full length
                trascriptionSteps.push(el) //retain time as transcription step 
        }
        else{
                AfterTrascription.push(el) //otherwise it is a time step after thascription end
            }
    })
    trascriptionSteps.push(AfterTrascription[0]) //the end of transcription is added in both lists
    
    //We want to make linear scale till transcription end 
    //and log scale after transcription ends

    let maxtime = d3new.max(filteredData, d =>+d.time)
    //I use filtered data to ignore time steps in which all stuctures are with ocuppancy smaller than threshhold
    let mintime = d3new.min(filteredData, d => +d.time) //I use the +(0) to automatically convert to Number, otherwise it would be string
    let minlintime=d3new.min(trascriptionSteps, d=>+d[0])
    let maxlintime=d3new.max(trascriptionSteps, d=>+d[0])
    //console.log("time", minlintime, maxlintime)
    let minlogtime=d3new.min(AfterTrascription, d=>+d[0])
    let maxlogtime=d3new.max(AfterTrascription, d=>+d[0])
    //console.log(minlogtime, maxlogtime)

    tableContainer.selectAll("p").remove()
    tableContainer.selectAll("#timesvg").remove()
  
    scalel = d3new.scaleLinear() //the linear scale
         .domain([minlintime, maxlintime]) 
         .range([30, (lineChartWidth-30)*.75]) //will always occupy 75% of the scale

    logscale = d3new.scaleLog() //    LOG SCALE, treat 0 as exception still TO DO!!!!!
          .domain([minlogtime, maxlogtime])
          .range([(lineChartWidth-30)*.75, lineChartWidth-30]) //the last 25% will be occupied by the log scale


    const combinedScale = time => time &lt; maxlintime  //define the combined scale that identifies on which scale we are
        ? scalel(time)  //if time is lower that the maximal linear time  we are on the linear scale
        : logscale(time); //else on the log scale

    svg = d3new.select("#tableContainer")
        .append("svg")
        .attr("width", lineChartWidth)
        .attr("height", 120)
        .attr("id", "timesvg"); //create the svg containing the scales
    
     //the lin and log scale on the bottom, positions were defined
    let x_axislog = d3new.axisBottom()
         .scale(logscale);
    let x_axislin = d3new.axisBottom()
         .scale(scalel);
    //and the vertical nucleotide  
    let nucleotideScale = d3new.scaleLinear()
        .range([80, 0]);
                    

    //Append group and insert axes
    nucleotideScale.domain([0, sequenceLength]);
    var y_axis = d3new.axisLeft()
        .scale(nucleotideScale)
    
        
    let rainbowScale = (t) => { //console.log(t/ sequenceLength)
        return d3.hcl(360*t*t/(sequenceLength), 100, 55); 
        //return d3.hcl(360* t/(sequenceLength), 100* t/(sequenceLength), 55); 
       // return d3.hcl(360* t, 100, 55); 
    };
    calculateNucleotideColors(filteredData) 

 function createScaleColors(){
    function mostOccupiedperTime()   {
        let mostoccupiedpertime=[]
        nestedData.forEach(el=>{  
            let best=el[1][0]
            let all=el[1]
            all.forEach(e=>{ //console.log(best.occupancy, "   " ,e.occupancy)
                if (e.occupancy>=best.occupancy){best=e}})
            mostoccupiedpertime.push([el[0], best])
            })    
        let mostocc=[mostoccupiedpertime[0]]
        mostoccupiedpertime.forEach((el,i)=>{
            //console.log(mostocc[mostocc.length-1][1].id,"  ", el[1].id)

            if (el[1].id!=mostocc[mostocc.length-1][1].id){
                mostocc.push([el[0], el[1]])
            }
        })
        return mostocc
    }

    let mostocc=mostOccupiedperTime()

    mostocc.forEach((el,i)=>{
        let end=0
        if (i== mostocc.length-1){
            end=lineChartWidth-30
        }
        else{
            end=combinedScale(mostocc[i+1][0])
        }
        
        svg.selectAll(".rectculoare"+i)
            .data(el[1].colors)
            .enter()
            .append("rect")
            .attr(`class`,'rectculoare'+i)
            .attr("id", (d,j)=> "rectculoare"+el[0]+d+j)
            .attr("width",end-combinedScale(el[0]))
            .attr("height", 80/sequenceLength)
            .attr("transform", (d,k)=> `translate(${+combinedScale(el[0])},${nucleotideScale(k)+10})`)
            .attr("fill", (d) => {return `${(d)}`; })
            .each(function(d,i) {//console.log("ha"+d+"ind "+i)
            })

            })
}      
createScaleColors()   
function drawScales(){
svg.append("g").attr("width", lineChartWidth)
        .attr("height", 110)
        .attr("transform", "translate (30,10)")
        .call(y_axis)    
    svg.append("g").attr("transform", "translate (0,90)").attr("height", 110).call(x_axislin);
    svg.append("g").attr("transform", "translate (0,90)").attr("height", 110).call(x_axislog).attr("color", "blue");    
}
drawScales()
function drawCirclesForTimepoints(){
    const timePoints = nestedData.map(d => +d[0]);
    
    d3new.select("#timesvg").selectAll('.timePoint').remove();
    d3new.select("#timesvg").selectAll('.timePoint').data(timePoints)
        .enter()
            .append('circle')
                .attr('class', 'timePoint')
                .attr('cx',d =>combinedScale(d))//  scale(d))
                .attr('cy', 90)
                .attr('r', 1)
                .attr('fill', 'none')
                .attr('stroke', 'black')
                .attr('strokeWidth', 1);
}
drawCirclesForTimepoints()

    let strToPlot=[]
    function StructuresToPlot(time){nestedData.forEach(element => {
            if (element[0] == time) {
                strToPlot = element[1] 
                } 
            })
    }
    if (prevtime==null){
        prevtime = mintime
    }
    strToPlot=StructuresToPlot(prevtime)
    PLOT(prevtime)
    showLine(combinedScale(prevtime)) 

    function ShowEndOfTranscriptionLine(){
        svg.append("line") //append black line to mark end of transcription
            .attr("class", "transcriplengthLine")
            .attr("x1", scalel(maxlintime))  
            .attr("y1", 0)
            .attr("x2", scalel(maxlintime))  
            .attr("y2", 120)
            .style("stroke-width", 1.5)
            .style("stroke","black")
           .style("fill", "none");
    }
    ShowEndOfTranscriptionLine()

    //toggle animation state on button click
    let delayPLOT = undefined;
    let playAnimation = false;
    let play = d3new.select("#toggleAnimation");
    let elementIndex = 0;
    play.on("click", () => {playAnimation = !playAnimation    
        nestedData.forEach(element => {
            if (element[0] == +prevtime) {
                elementIndex=nestedData.indexOf(element)
                }
            })
    })
    
    const animationDelay = 400;
    setInterval(() => {
        if (!playAnimation) {//console.log("aici ");\\ ruleaza o data pe secunda, nu e foarte frumos...
                 return;
        }
        const element = nestedData[elementIndex];
        PLOT(element[0])
        showLine(combinedScale(element[0]))
        prevtime=element[0]
        elementIndex += 1;
        if (elementIndex >= nestedData.length)
            elementIndex = 0;
    }, animationDelay);

    let mousetime=30
    svg.on("click", function (event) {
        if (playAnimation) {playAnimation=!playAnimation};
        mouseactive=!mouseactive;
        
       // console.log("event", d3new.pointer(event)[0]);
        //scale invert for combined scale
        (d3new.pointer(event)[0]&lt;scalel(maxlintime))
        ?mousetime = scalel.invert(d3new.pointer(event)[0]) 
        :mousetime= logscale.invert(d3new.pointer(event)[0])
       //console.log(mousetime-scale.invert(d3new.pointer(event)[0]) )
       
        
        if (d3new.pointer(event)[0] >= 30 &amp;&amp; d3new.pointer(event)[0] &lt;= lineChartWidth-30) {
            showLine(d3new.pointer(event)[0])
        }
        for (let t in data) {
            if (data[t].time &lt;= mousetime) { 
                realtime = data[t].time 
            }
        }
        if (prevtime != realtime) {
            prevtime = realtime
            PLOT(realtime)
        }
    })
    timer(0)
    svg.on("mousemove", (event) => {
        
        if (playAnimation) return;
        if (!mouseactive) return;
        let x = d3new.pointer(event)[0];
        //let x = d3new.pointer(event, event.target)[0];
       
        //scale invert for combined scale
        (x &lt;= scalel(maxlintime))
              ? mousetime = scalel.invert(x) 
              : mousetime = logscale.invert(x)
       // console.log(mousetime- scale.invert(x) )
        //console.log(mousetime)
        if (x >= 30 &amp;&amp; x &lt;= lineChartWidth-30) {
            showLine(x)
        }

        for (let t in data) {
            if (data[t].time &lt;= mousetime) { 
                realtime = data[t].time 
            }
        }
        if (prevtime != realtime) {
            prevtime = realtime
            
            // timer()
            if (delayPLOT) clearTimeout(delayPLOT);
            delayPLOT = setTimeout(PLOT, 10*maxNoStr, realtime);
            
            // PLOT(realtime)
            // timer("mouse")
           // timer(1)
        }
    })

    function showLine(coord, color="red") {
        svg.selectAll(".currenttimeLine").remove()
        svg.append("line")
            .attr("class", "currenttimeLine")
            .attr("x1", coord)  
            .attr("y1", 0)
            .attr("x2", coord)  
            .attr("y2", 120)
            .style("stroke-width", 1)
            .style("stroke",color)
            .style("fill", "none");
    }
    function formatColors (colors) {
                return colors.map(function(c) {
                  return c.rgb().toString();
                })
              }

    function makeTreemapData(data) {
        return [
            { name: "parent", parent: null, value: 0, str:"", colors: "" },
            ...data.map(el => (
                { 
                    name: el.id, parent: "parent", value: el.occupancy, str: el.structure, colors:formatColors(el.colors) }))
        ]
    }

    function PLOT(realtime) {       
         timer(1)
        nestedData.forEach(element => { 
            if (element[0] == realtime) {
                 strToPlot = element[1] 
                } 
            })
        
        if (strtoPlotprev!=strToPlot) {
          // console.log(strToPlot)
       
           //generate treemap data
        const treemapData = makeTreemapData(strToPlot);
       // console.log(treemapData)
        const svgWidth = lineChartWidth
        const svgHeight = 500
        var root = d3new.stratify()
            .id(function (d) { return d.name; })   // Name of the entity (column name is name in csv)
            .parentId(function (d) { return d.parent; })   // Name of the parent (column name is parent in csv)
            (treemapData);
        root.sum(d => +d.value)   // Compute the numeric value for each entity
        d3new.treemap()
            .size([svgWidth, svgHeight])
            .padding(4)
            (root)

            //  console.log(root.leaves())
        
        //const containers = {};
        viscontainer.select("#treemapdiv").remove()

        //what if I work with the join here 
        //in both- update dimensions
        //new, generate
        //only in old, delete
        


        viscontainer.append("div").attr("id", "treemapdiv") 
 //let cells=viscontainer.select("#treemapdiv").
            .style('position', 'relative')
            .style("width", `${svgWidth}px`)
            .style("height", `${svgHeight}px`)
            .selectAll(".svg").remove() // leave out
            .data(root.leaves())
            //cells.exit().remove() update size to 0
           // cells//
            .enter()
            .append("svg").attr("id",  function (d) { //console.log(d); // updare size 
                return "svg"+d.data.name})
            //.attr( 'display', 'inline')
            .style('position', 'absolute')
            .style('left',  d =>{ return d.x0; })
            .style('top', function (d) { return d.y0; })
            .style('width', function (d) { return (d.x1 - d.x0); })
            .style('height', function (d) { return (d.y1 - d.y0); })
            //.style('position', 'relative')
            .style("stroke", "black")
            .style("fill", "#62b6a2")
            .style("border", "thin solid black")
            .each(function (d) {
               // console.log("d",d)
                let str=''
                let rectname="svg"+d.data.name
                if ( d.data.str != '') {
                    //timer() 
                    containers[rectname] = new FornaContainer('#' + rectname, 
                    {zoomable:false, editable:false,animation:false, transitionDuration:0, });//labelInterval:0
                   //timer("1")
                    containers[rectname].transitionRNA(d.data.str);  
                   //timer(2)
                   // console.log(containers)   
                   let colorStrings = d.data.colors.map(function(d, i) {
                       //console.log(d)
                    return `${i+1}:${d}`;
                });

                let colorString = colorStrings.join(' ');

                containers[rectname].addCustomColorsText(colorString);              
                
            }
                })
        //         ;
        
        // viscontainer.select("#treemapdiv").selectAll(".svg")
        //       .data(root.leaves())
        //       .enter()
            .append("text")
            .style('position', 'relative')
            .attr("x", function (d) { return 1 })    //  to adjust position (to the right)
            .attr("y", function (d) { return  10 })    //  to adjust position (lower)
            .text(function (d) {
                    return d.data.name
                    })
            .attr("font-size", "10px")
            .attr("font-family", "DejaVu Sans Mono")
            .attr("fill", "white");
              

            var columns = ['name','time', 'occupancy', 'structure', 'energy'];
            var colnames = ['ID',// 'Time', 
            'Occupancy', 'Structure', 'Energy'];    

        d3new.select("#tableContainer")
            .selectAll("table").remove()
        d3new.select("#tableContainer")
            .selectAll("time").remove()
        let time=d3new.select("#tableContainer").append("time")
        .style("font-family", "DejaVu Sans Mono")
        let structures = d3new.select("#tableContainer").append("table")
            .style("font-family", "DejaVu Sans Mono")
        //let colnames = ['ID',"Time" , 'Occupancy','Structure', 'Energy']
        //let columns = ['id', 'time', 'occupancy', 'structure', 'energy'];
        let ttime = time.append("thead").append('tr')
        ttime.append("td").text("Selected time point: "+strToPlot[0].time)
        
        let th = structures.append("thead")
        //th.append('tr').append("td").text(d.time)
        th.append('tr').selectAll('th')
                    .data(colnames).enter()
                    .append('th')
                    .text(function (column) { return column; });
                // th.append("td").text("ID")
                // th.append("td").text("Time")
                // th.append("td").text("Ocupancy")
                // th.append("td").text("Structure")
                // th.append("td").text("Energy")
         
                
   let tbody = structures.append('tbody')
 //structures.selectAll(".tableData")
 //console.log(strToPlot)
 let tr =tbody.selectAll("tr").data(strToPlot).enter()
            .append("tr").attr("class", "tableData")
            .selectAll("td").data(d => {console.log()
               return [{column:"id", value:d.id},//{column:"time", value: d.time},
                {column:"oc", value:Math.round(d.occupancy*1000)/1000}, 
                {column:"str", value:d.structure, col:d.colors},{column:"en", value: d.energy}]//, {column:"col", value:d.colors}]
                }).enter()
            
            //.text(dd => dd.value)
            tr.each((dd,j) =>{console.log(dd.value)
               
                if (dd.column=="id"){tbody.append("tr")
                 }
                //console.log("dd", dd)
                 if (dd.column=="str"){
                   
                    let tb=tbody.append("td")
                    tb.selectAll('span').remove()
                    for (let i = 0; i &lt; dd.value.length; i++) {
                      tb.append('span')
                      .style('background-color',dd.col[i])
                      .text(dd.value[i])
                    }
                    //text(dd.value).style("background-color", "red")
                }
                
                else  if (dd.column!="str"){tbody.append("td").text(dd.value )}
        })
       
  }



       
    
    else {strtoPlotprev=strToPlot}     
    return realtime
    }
    // function calculateColorPerTimePoint(nestedData) {
    //     nestedData.forEach((d) => {
    //         d.values.sort((a,b) => { return (+b.occupancy) - (+a.occupancy); });
    //     });
    // }

    function calculateNucleotideColors(data) {
        data.forEach(function(d, i) {
            // determine the colors of each nucleotide according to the position
            // of the stem that they're in
            // each 'd' is a line in the dr transfomer output
            d.time = +d.time;
            d.occupancy = +d.occupancy;

            // get a pairtable and a list of the secondary structure elements
            let pt = rnaUtilities.dotbracketToPairtable(d.structure);
            //console.log(pt)
            let elements = rnaUtilities.ptToElements(pt, 0, 1, pt[0], []);

            // store the colors of each nucleotide
            let colors = Array(pt[0]).fill(d3.hsl("white"));
            //console.log(elements)
        

            for (let i = 0; i &lt; elements.length; i++) {
                if (elements[i][0] != 's')
                    continue;     //we're not interested in anything but stems

                // for each nucleotide in the stem
                // assign it the stem's average nucleotide number
                let averageBpNum = elements[i][2].reduce(
                    (a,b) => { return a+b }, 0) / elements[i][2].length;
                   
                // convert average nucleotide numbers to colors
                elements[i][2].map((d) => {
                    let nucleotideNormPosition = nucleotideScale(+averageBpNum);
                    colors[d-1] = rainbowScale(nucleotideNormPosition);
                    //console.log(elements[i])
                    //console.log(i, averageBpNum, nucleotideNormPosition,  colors[d-1])
                });


                // each structure gets its own set of structures
            }
            d.colors = colors;
            //console.log(d)
        });
    }



} 






function timer(lap){ 
    if(lap) console.log(`${lap} in: ${(performance.now()-timer.prev).toFixed(3)}ms`); 
    timer.prev = performance.now();
}

function debounce(func, time){
    var time = time || 100; // 100 by default if no param
    var _timer;
    return function(event){
        if (_timer) clearTimeout(_timer);
        _timer = setTimeout(func, time, event);
    };
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#downloadPng">downloadPng</a></li><li><a href="global.html#filename">filename</a></li><li><a href="global.html#mouseactive">mouseactive</a></li><li><a href="global.html#occupancyTreshold">occupancyTreshold</a></li><li><a href="global.html#preparePlotArea">preparePlotArea</a></li><li><a href="global.html#readFromFileRadio">readFromFileRadio</a></li><li><a href="global.html#readFromFileUpload">readFromFileUpload</a></li><li><a href="global.html#sequenceLength">sequenceLength</a></li><li><a href="global.html#ShowData">ShowData</a></li><li><a href="global.html#start">start</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Mon Feb 14 2022 18:54:04 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
